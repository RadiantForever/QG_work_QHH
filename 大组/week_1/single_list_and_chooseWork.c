#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;

typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//初化链表
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//初始化节点
Node* initListWithElem(ElemType e)
{
	Node *node = (Node*)malloc(sizeof(Node));
	node->data = e;
	node->next = NULL;
	return node;
}

//头插法函数
int insertHead(Node* L, ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//遍历链表
void listNode(Node* L)
{
	Node *p = L->next;
	while(p != NULL)
	{
		printf("%d ", p->data);
		p = p->next;
	}
	printf("\n");
}

//获取尾部结点
Node*  get_tail(Node  *L)
{
	Node *p = L;
	while(p->next != NULL)
	{
		p = p->next;
	}
	return p;
}

//尾插法函数
Node* insertTail(Node *tail, ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	tail->next = p;
	p->next = NULL;
	return p;
}

//尾插法（节点）
Node* insertTailWithNode(Node *tail, Node *node)
{
	tail->next = node;
	node->next = NULL;
	return node;
}

//指定位置插入
int insertNode(Node *L, int pos, ElemType e)
{
	Node *p = L;
	int i = 0;
	while(i < pos-1)
	{
		p = p->next;
		i++;
		if (p == NULL)
		{
			return 0;
		}
	}
	Node *q = (Node*)malloc(sizeof(Node));
	q->data = e;
	q->next = p->next;
	p->next = q;
	return 1;
}

//删除节点
int deleteNode(Node *L, int pos)
{
	Node *p = L;
	int i = 0;
	while(i < pos-1)
	{
		p = p->next;
		i++;
		if (p == NULL)
		{
			return 0;
		}
	}
	if(p->next == NULL)
	{
		printf("输入的删除的位置出错了\n");
		return 0;
	}

	Node *q = p->next;
	p->next = q->next;
	free(q);
	return 1;
}

//获取链表长度函数
int listLength(Node *L)
{
	Node *p = L;
	int len = 0;
	while(p != NULL)
	{
		p = p->next;
		len++;
	}
	return len;
}

//释放链表
void freeList(Node *L)
{
	Node *p = L->next;
	Node *q;

	while(p != NULL)
	{
		q = p->next;
		free(p);
		p = q;
	}
	L->next = NULL;
}

//查找倒数第k个节点
int findNodeFS(Node *L, int k)
{
	Node *fast = L->next;
	Node *slow = L->next;

	for (int i = 0; i < k; i++)
	{
		fast = fast->next;
	}

	while(fast != NULL)
	{
		fast = fast->next;
		slow = slow->next;
	}

	printf("倒数第%d个节点值为：%d\n", k, slow->data);
	return 1;
}

// 单链表奇偶调换函数
void swapPairs(Node* head) {
	if (head == NULL || head->next == NULL)
		return ;

	Node* prev = head;
	Node* curr = head->next;

	while (curr != NULL && curr->next != NULL) {
		// 交换当前节点和下一个节点
		Node* nextNode = curr->next;
		curr->next = nextNode->next;
		nextNode->next = curr;
		prev->next = nextNode;

		// 移动指针
		prev = curr;
		curr = curr->next;
	}
}

//查找两个节点共同后缀的起始位置
Node* findIntersectionNode(Node *headA, Node *headB)
{
	if(headA == NULL || headB == NULL)
	{
		return NULL;
	}

	Node *p = headA;
	int lenA = 0;
	int lenB = 0;
	while(p != NULL)
	{
		p = p->next;
		lenA++;
	}

	p = headB;
	while(p != NULL)
	{
		p = p->next;
		lenB++;
	}

	Node *m;
	Node *n;
	int step;
	if (lenA > lenB)
	{
		step = lenA - lenB;
		m = headA;
		n = headB;
	}
	else
	{
		step = lenB - lenA;
		m = headB;
		n = headA;
	}

	for (int i = 0; i < step; i++)
	{
		m = m->next;
	}

	while(m != n)
	{
		m = m->next;
		n = n->next;
	}
	return m;
}

//删除绝对值相同的节点
void removeNode(Node *L, int n)
{
	Node *p = L;
	int index;
	int *q = (int*)malloc(sizeof(int)*(n+1));

	for (int i = 0; i < n+1; i++)
	{
		*(q + i) = 0;
	}

	while(p->next != NULL)
	{

		index = abs(p->next->data);
		if(*(q+index) == 0)
		{
			*(q + index) = 1;
			p = p->next;
		}
		else
		{
			Node *temp = p->next;
			p->next = temp->next;
			free(temp);
		}

	}
	free(q);
}

//反转链表                 大组作业选做内容第四项：反转链表
Node* reverseList(Node* head)
{
	Node *first = NULL;
	Node *second = head->next;
	Node *third;

	while(second != NULL)
	{
		third = second->next;
		second->next = first;
		first = second;
		second = third;
	}
	Node *hd = initList();
	hd->next = first;

	return hd;
}

//删除中间节点函数
int delMiddleNode(Node *head)
{
	Node *fast = head->next;
	Node *slow = head;

	while(fast != NULL && fast->next != NULL)
	{
		fast = fast->next->next;
		slow = slow->next;
	}
	Node *q = slow->next;
	slow->next = q->next;
	free(q);
	return 1;
}

//寻找中间节点函数            大组作业选做内容第二项：寻找中间节点
Node* findMiddleNode(Node *head)
{
	Node *fast = head;
	Node *slow = head;

	while(fast != NULL && fast->next != NULL)
	{
		fast = fast->next->next;
		slow = slow->next;
	}
	return slow;
}
//链表重新排序
void reOrderList(Node *head)
{
	Node *fast = head;
	Node *slow = head;
	while(fast != NULL && fast->next != NULL)
	{
		fast = fast->next->next;
		slow = slow->next;
	}

	Node *first = NULL;
	Node *second = slow->next;
	slow->next = NULL;
	Node *third = NULL;

	while(second !=NULL)
	{
		third = second->next;
		second->next = first;
		first = second;
		second = third;
	}

	Node *p1 = head->next;
	Node *q1 = first;
	Node *p2, *q2;
	while(p1 != NULL && q1 != NULL)
	{
		p2 = p1->next;
		q2 = q1->next;

		p1->next = q1;
		q1->next = p2;

		p1 = p2;
		q1 = q2;
	}
}

//判断链表是否有环函数                        大组作业选做内容第三项：是否有环
int isCycle(Node *head)
{
	Node *fast = head;
	Node *slow = head;

	while(fast != NULL && fast->next != NULL)
	{
		fast = fast->next->next;
		slow = slow->next;
		if (fast == slow)
		{
			return 1;
		}
	}

	return 0;
}

//找到链表环的入口函数
Node* findBegin(Node *head)
{
	Node *fast = head;
	Node *slow = head;

	while(fast != NULL && fast->next != NULL)
	{
		fast = fast->next->next;
		slow = slow->next;
		if (fast == slow)
		{
			Node *p = fast;
			int count = 1;
			while(p->next != slow)
			{
				count++;
				p = p->next;
			}

			fast = head;
			slow = head;

			for (int i = 0; i < count; i++)
			{
				fast = fast->next;
			}

			while(fast != slow)
			{
				fast = fast->next;
				slow = slow->next;
			}
			return slow;
		}
	}
	return NULL;
}
int main(int argc, char const *argv[])
{
	Node *list = initList();

	Node *tail = get_tail(list);

	tail = insertTail(tail, 1);
	tail = insertTail(tail, 2);
	tail = insertTail(tail, 3);
	tail = insertTail(tail, 4);
	tail = insertTail(tail, 5);
	tail = insertTail(tail, 6);
	tail = insertTail(tail, 7);
	tail = insertTail(tail, 8);
	int mid=findMiddleNode(list)->data;//选做任务二
	printf("中间节点值为%d\n", mid);





	swapPairs(list);//选做任务一
	printf("奇偶对换:\n");
	listNode(list);



	//选做任务四
	list=reverseList(list);
	printf("reverseList:\n");
	listNode(list);



	// 设置链表环
	Node*newtail=get_tail(list);
	Node *cycleStart = list->next->next->next;
	printf("cycleStart is %d\n", cycleStart->data);
	newtail->next = cycleStart;

	//选做任务三
	int yes1_or_no0 = isCycle(list);
	if (yes1_or_no0)
		printf("有环\n");
	else
		printf("无环\n");


	Node *p = findBegin(list);
	printf("数值%d为环起点处的数值\n", p->data);

	return 0;
}